composer parse-connections
 (def a: <node´'\w+'>; <=':'>) <node>+ -> {a: $a, b: $}
 rule node: (<WS>) <node´'\w+'>
end parse-connections

def connections: {|$IN::lines -> parse-connections|};

processor Counter
  @:0;
  source next
    @Counter: $@Counter + 1;
    $@Counter!
  end next
end Counter

def node-id-generator: $Counter;

// Represent nodes as numbers
def node-ids: {|$connections({node: §.a})..., $connections({node: §.b})...|} -> $({id: $node-id-generator::next, node:});
def id-connections: [(($connections join $node-ids({aid: §.id, a: §.node})) join $node-ids({bid: §.id, b: §.node})) -> $({aid:, bid:})...];
def adjacency-list: $id-connections -> \(
  @:id´1:[1..$node-ids::count -> []];
  $... -> #
  $@ !
  <> ..|@($.aid): $.bid; ..|@($.bid): $.aid;
\);

source kargers-algorithm
  @: {
    edges: $id-connections,
    nodes: id´1:[id´1..id´$node-ids::count]
  };
  $@.nodes::length..3:-1 -> #
  $@ !
  <>
    def edge: $@.edges::length -> SYS::randomInt -> $ + 1 -> ^@.edges($);
    @.nodes($edge.bid): $edge.aid; // union-find
    @.edges: [$@.edges... -> \(
      when <{aid: <=$edge.aid>, bid: <=$edge.bid>}|{aid: <=$edge.bid>, bid: <=$edge.aid>}> do !VOID
      when <{aid: <=$edge.bid>}> do {aid: $edge.aid, bid: $.bid} !
      when <{bid: <=$edge.bid>}> do {aid: $.aid, bid: $edge.aid} !
      otherwise $!
    \)];
end kargers-algorithm

templates collect-groups
  def ids: $;
  templates get-group
     when <?($ids($) <=$>)> do $!
     otherwise $ids($) -> #
  end get-group
  {| $ids::first..$ids::last -> {id: $, group: $ -> get-group}|} -> $(collect {count: Count} by $({group:})) !
end collect-groups

// part 1
source part1
  $kargers-algorithm -> #
  when <{edges: <[](3)>}> do
    $.nodes -> collect-groups -> [$...] -> \($ -> !OUT::write $!\) -> $(1).count * $(2).count !
  otherwise
    '.$.edges::length;.' -> !OUT::write
    $kargers-algorithm -> #
end part1
$part1 -> '$#10;$;$#10;' -> !OUT::write

test 'example'
  use shadowed core-system/
    processor MockIn
      source lines
        [
          'jqt: rhn xhk nvd',
          'rsh: frs pzl lsr',
          'xhk: hfx',
          'cmg: qnr nvd lhk bvb',
          'rhn: xhk bvb hfx',
          'bvb: xhk hfx',
          'pzl: lsr hfx nvd',
          'qnr: nvd',
          'ntq: jqt hfx bvb xhk',
          'nvd: lhk',
          'lsr: lhk',
          'rzs: qnr cmg lsr rsh',
          'frs: qnr lhk lsr'
        ]... !
      end lines
    end MockIn
    def IN: $MockIn;
  end core-system/

  assert $part1 <=54"1"> 'part 1'
end 'example'
